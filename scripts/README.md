The steps that should be taken to deploy the Kubernetes cluster

I. Preliminary:
[MASTER/WORKER] Create the directory for your Kubernetes code, e.g. with `mkdir -p kubernetesaugment/kubernetes-cpupinning/`, `cd` into it, and then clone Github repo with the code with command `git clone --single-branch --branch feature-cpupinning-augmented https://github.com/Remit/kubernetes`. This is a one-time action.

II. One-time:
1. [MASTER/WORKER] Start by running `mem-swapoff.sh` script. Kubernetes requires memory swap to be turned off on the nodes in the cluster - this improves the performance; this script will check whether the swap is already turned off, and, if not, it will turn it off and reboot the machine. This is a one-time ~time-consuming action.
2. [MASTER/WORKER] Continue by running `prepare-env.sh` script with Kubernetes directory given as a script parameter. E.g. `sudo ./prepare-env.sh kubernetesaugment/kubernetes-cpupinning/kubernetes`. This script downloads and sets up all the necessary compilation/deployment tools such as e.g. golang, Docker CE, make, gcc, CNI. This is a one-time time-consuming action.
3. [MASTER/WORKER] Continue by running `compile-all.sh` script with Kubernetes directory given as a script parameter; this will compile the downloaded Kubernetes code. E.g. `sudo compile-all.sh kubernetesaugment/kubernetes-cpupinning/kubernetes`. This is a one-time time-consuming action.

III. Recurring after each code update:
1. [MASTER/WORKER] Recompilation of `kubelet` after code update should be done by running `sudo ./kubelet-recompile.sh kubernetesaugment/kubernetes-cpupinning/kubernetes`; this script will pull the updates from Github and will compile only kubelet with further copying to the folder at which kubelet.service points.

IV. Recurring for each cluster deployment:
1. [MASTER] Deploy Kubernetes cluster's master by running `deploy-kubernetes-master.sh` script. It accepts the following parameters: 1) CPU assignment policy - static (modified by us in code!) or none (can be used as a baseline in tests); 2,3,4) Reserved resources for Kubernetes (CPU shares, memory shares and ephemeral storage). There are also default values for these, so the script can also run without parameters specified. If the parameters should be specified explicitly, then the format is `sudo ./deploy-kubernetes-master.sh static 300m 300Mi 1Gi`. Among the lines of the console output there will be the join command to be executed on the worker node -> it should be given as an input to the next script.
2. !!! REQUIRES TESTING !!! [WORKER] Join worker node to the cluster by running `deploy-kubernetes-worker.sh` script. It accepts master node's ip, token, and CA certificate hash as input parameters (generated by kubeadm init), e.g. `sudo ./deploy-kubernetes-worker.sh 192.168.128.105:6443 rxuk0j.syohx7cnq58thca8 sha256:466dacaf450aa834090da3587723880da9bf004f736320a28552adcec1b780ea`. The deployment of CNI is not yet clear, hence a testing is required.
3. [MASTER] Now, the cluster can accept commands issued from the master node by executing in CLI `sudo kubectl --kubeconfig /etc/kubernetes/admin.conf <<command-name and params>>`. Some common examples:
- Get status of nodes: `sudo kubectl --kubeconfig /etc/kubernetes/admin.conf get nodes`
- Get status of pods in all namespaces: `sudo kubectl --kubeconfig /etc/kubernetes/admin.conf get pods`
- Get detailed status of a particular pod from a default namespace: `sudo kubectl --kubeconfig /etc/kubernetes/admin.conf describe pod bootcamp2`
- Get logs of the pod: `sudo kubectl --kubeconfig /etc/kubernetes/admin.conf logs bootcamp2`
4. [MASTER/WORKER] Tear down the cluster by running `sudo reset-cluster.sh`.

V. Benchmarking on the running cluster:
!WORK-IN-PROGRESS!
[MASTER] `sudo ./run-parsec-benchmark.sh ~/kubernetes/ 2`
